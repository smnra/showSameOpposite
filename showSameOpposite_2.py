# -*- coding: utf-8 -*-
"""
/***************************************************************************
 showSameOpposite
                                 A QGIS plugin
 showSameOpposite
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-04-17
        git sha              : $Format:%H$
        copyright            : (C) 2025 by showSameOpposite
        email                : showSameOpposite
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
################################# 远程调试 #################################################
import sys,os
debuger_path = os.path.join(os.path.dirname(__file__),'pydevd-pycharm.egg')
print(debuger_path)
sys.path.append(debuger_path)

# import pydevd_pycharm
# pydevd_pycharm.settrace('localhost', port=53001, stdoutToServer=True, stderrToServer=True)
###################################################################################################










from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction


# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog

from .showSameOpposite_dialog import showSameOppositeDialog
import os.path,math










from qgis.PyQt.QtGui import QColor
from qgis.utils import iface

from qgis.gui import QgsMapTool, QgsMapMouseEvent, QgsHighlight
from qgis.core import QgsProject, QgsPointXY, QgsGeometry, QgsCoordinateTransform
from qgis.core import QgsRectangle, QgsFeatureRequest,QgsExpression, QgsWkbTypes,QgsVectorLayer,QgsFillSymbol,QgsFeature
from PyQt5.QtWidgets import QListWidget, QDialog, QVBoxLayout, QListWidgetItem, QMessageBox











# 导入图层触发器  主要用于添加索引对象 和移除临时图层
from  .layerMonitor import LayerMonitor,spatial_index





band_to_radius = {
                 '800M':200,
                 '900M':180,
                 '1.8G':160,
                 '1800M':160,
                 '2.1G':140,
                 '2100M':140,
                 '2.3G':120,
                 '2300M':120,
                 '3.5G':100,
                 '3500M':100
}

net_to_beamwidth = {
                 '4G':60,
                 '5G':40,
}







class showSameOpposite:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory

        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'showSameOpposite_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        self.monitor = LayerMonitor()   # 创建图层触发监听实例

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        
        self.action = QAction(QCoreApplication.translate('showSameOpposite', 'showSameOpposite'), self.iface.mainWindow())
        self.action_config = QAction(QCoreApplication.translate('showSameOpposite', 'Config'), self.iface.mainWindow())
        
        self.iface.registerMainWindowAction(self.action, 'Shift+S')
        self.iface.registerMainWindowAction(self.action_config, 'Shift+C')
        
        self.action.setIcon(QIcon(':/plugins/showSameOpposite/icon.png'))
        self.action_config.setIcon(QIcon(':/plugins/showSameOpposite/icon.png'))
        
        self.action.triggered.connect(self.run)
        self.action_config.triggered.connect(self.run_config)
        
        self.action.setEnabled(True)
        self.action_config.setEnabled(True)

        self.action.setWhatsThis("select a cell.")
        self.action_config.setWhatsThis("Config sector draw")

        self.iface.addToolBarIcon(self.action)
        self.iface.addToolBarIcon(self.action_config)

        self.iface.addPluginToMenu(QCoreApplication.translate('showSameOpposite', 'showSameOpposite'),self.action)
        self.iface.addPluginToMenu(QCoreApplication.translate('showSameOpposite', 'showSameOpposite'),self.action_config)

        self.first_start = True


    def unload(self):
        try:
            """Removes the plugin menu item and icon from QGIS GUI."""
            self.iface.unregisterMainWindowAction(self.action)
            self.iface.unregisterMainWindowAction(self.action_config)

            self.iface.removeToolBarIcon(self.action)
            self.iface.removeToolBarIcon(self.action_config)

            self.iface.removePluginMenu(QCoreApplication.translate('showSameOpposite', 'showSameOpposite'), self.action)
            self.iface.removePluginMenu(QCoreApplication.translate('showSameOpposite', 'showSameOpposite'), self.action_config)

            # 清理信号连接
            # QgsProject.instance().layersAdded.disconnect(self.monitor.init_existing_layers)
            QgsProject.instance().layersAdded.disconnect(self.monitor.on_layers_added)
            QgsProject.instance().layersRemoved.disconnect(self.monitor.on_layers_removed)
        except Exception as e:
            print(e)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = showSameOppositeDialog()

        # show the dialog
        # self.dlg.show()
        # Run the dialog event loop
        # result = self.dlg.exec_()
        # See if OK was pressed
        # if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            # pass
        
        # 激活工具
        selectTool = MultiSelectMapTool(iface.mapCanvas())
        iface.mapCanvas().setMapTool(selectTool)
                
        
        
        
    def run_config(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started

        # pydevd_pycharm.settrace('localhost', port=53001, stdoutToServer=True, stderrToServer=True)
        self.dlg = showSameOppositeDialog()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
        
        # 激活工具
        selectTool = MultiSelectMapTool(iface.mapCanvas())
        iface.mapCanvas().setMapTool(selectTool)  
        
        
        
        
        








class MultiSelectMapTool(QgsMapTool):
    def __init__(self, canvas):
        super().__init__(canvas)
        self.canvas = canvas
        self.source_fid = ''
        self.source_layer = ''


    def deduplicate_by_key(self,feature_list, key='sc_eci'):      # 要素的列表 安装要素的字段 key : sc_eci 去重
        # todo
        # 1. 选择要素时 按照要素的 字段 sc_eci 去重
        seen = set()
        result = []
        for feature in feature_list:
            if feature.attribute(key) not in seen:
                seen.add(feature.attribute(key))
                result.append(feature)
        return result


    def canvasReleaseEvent(self, event: QgsMapMouseEvent):
        # pydevd_pycharm.settrace('localhost', port=53001, stdoutToServer=True, stderrToServer=True)        # 调试代码
        # 获取点击点的坐标（地图坐标）
        point = self.toMapCoordinates(event.pos())
        # 获取所有可见的矢量图层
        layer = iface.activeLayer()
        found_features = []

        if layer.type() == layer.VectorLayer:
            try:
                # 将点坐标转换为图层坐标系
                transform = QgsCoordinateTransform(self.canvas.mapSettings().destinationCrs(), layer.crs(), QgsProject.instance())
                point_layer = transform.transform(point)
            except Exception as e:
                print(e)
            # 创建请求，查找在该点处的要素
            tolerance = self.canvas.mapUnitsPerPixel() * 5  # 5像素的容差
            rect = QgsGeometry.fromRect(QgsRectangle(point_layer.x() - tolerance, point_layer.y() - tolerance,
                                                     point_layer.x() + tolerance, point_layer.y() + tolerance))
            request = QgsFeatureRequest().setFilterRect(rect.boundingBox())
            for feature in layer.getFeatures(request):
                geom = feature.geometry()
                if geom.intersects(rect):
                    found_features.append(feature )

            # found_features 列表去重
            found_features = self.deduplicate_by_key(found_features,'sc_eci')

        # 显示选择对话框
        if len(found_features) > 0:
            dlg = QDialog()
            dlg.setWindowTitle("选择要素")
            layout = QVBoxLayout()
            list_widget = QListWidget()
            list_widget.setFixedSize(400, 300)  # 宽度 400px，高度 300px
            for feature in found_features:
                # 显示图层名和属性，例如第一个字段的值
                display_value = f"{feature.attribute('sc_eci')},{feature.attribute('sc_net')},{feature.attribute('sc_cjf')},{feature.attribute('sc_ventor')},{feature.attribute('sc_band')},{feature.attribute('sc_coverage_type')},{feature.attribute('sc_coverage_region')}"
                print(f"{layer.name()}: {display_value}")
                item_text = f"{layer.name()}: {display_value}"
                item = QListWidgetItem(item_text)
                item.setData(1024, (layer, feature.id()))
                list_widget.addItem(item)
            list_widget.itemDoubleClicked.connect(dlg.accept)
            layout.addWidget(list_widget)
            dlg.setLayout(layout)
            if dlg.exec_():
                selected_item = list_widget.currentItem()
                if selected_item:
                    source_layer, source_fid = selected_item.data(1024)
                    source_feature = source_layer.getFeature(int(source_fid))

                    # 选择要素500米范围内的所有要素
                    source_region = source_feature["sc_coverage_region"]
                    distance_dict = {'市区': 500, '县城': 1000, '乡镇': 1500, '农村': 3000}
                    distance = distance_dict[source_region]
                    source_distance_features = select_distance_features(source_layer, source_feature, distance=distance)

                    self.create_temp_layer(source_layer,source_distance_features, source_feature)
                    # self.canvas.refresh()
            else:
                print("提示", "未选择要素")
            
        else:
            print("提示", "未找到要素")









    def create_temp_layer(self,source_layer,source_distance_features,source_feature):
        tmp_layer_parname = '临时草图_SC_eci_'
        source_fid = source_feature.id()

        # 移除选择的元素
        iface.activeLayer().removeSelection()


        # 获取项目中所有图层
        all_layers = QgsProject.instance().mapLayers().values()
        # 筛选符合条件的图层
        layers_to_remove = [layer for layer in all_layers if tmp_layer_parname in layer.name()]
        # 删除图层并输出结果
        if layers_to_remove:
            for layer in layers_to_remove:
                QgsProject.instance().removeMapLayer(layer.id())
            print(f"已删除 {len(layers_to_remove)} 个包含 '{tmp_layer_parname}' 的临时图层")
        else:
            print(f"未找到临时图层: 包含 '{tmp_layer_parname}' 的图层")








        # 获取激活图层
        # source_layer = self.source_layer
        # 获取 点击元素的 id 列
        # source_fid = self.source_fid
        # source_fid = "[% $id %]"








        # 从 id 获取元素
        try:
            print('source_layer: ',source_layer, type(source_layer))
            print('source_distance_features: ',source_distance_features, type(source_distance_features))
            print('source_fid: ',source_feature, type(source_feature))


            # source_feature = source_layer.getFeature(int(source_fid))
            sc_eci = source_feature["sc_eci"]
            print('sc_eci',sc_eci)




            # todo
            print("使用 源小区覆盖区域 {'市区':500, '县城':1000, '乡镇':1500, '农村':3000} 米范围内的 目标小区 做为作为查找范围)")


            # 老方法:  从图层所有元素中  找出 sc_eci 相同的 目标小区
            # expression = QgsExpression(f'"sc_eci"={sc_eci}')
            # request = QgsFeatureRequest(expression)
            # matching_features = [f for f in source_layer.getFeatures(request)]

            # 新方法:  从 500米范围内的 目标小区中  做为查找范围  找出 sc_eci 相同的 目标小区
            matching_features = [f for f in source_distance_features if f['sc_eci'] == sc_eci]



            # 创建临时内存图层
            # 从要素获取  几何图形类型 'Polygon'  和 坐标系 srid
            geometry_type = 'Polygon'
            srid = '4326'
            if source_feature:
                try:
                    srid = source_layer.crs().authid().split(':')[1]
                except Exception as e:
                    print(e)

            print(f"{geometry_type}?crs=EPSG:{srid}")
            temp_layer = QgsVectorLayer(f"{geometry_type}?crs=EPSG:{srid}", f"{tmp_layer_parname}{sc_eci}", "memory")
            provider = temp_layer.dataProvider()


            # 给图层添加字段（如果需要）
            source_fields = source_layer.fields()  # 获取源图层的字段结构
            provider.addAttributes(source_fields)
            temp_layer.updateFields()  # 刷新字段结构


            # 修改图层样式
            symbol = QgsFillSymbol.createSimple({
                'color': 'rgba(244, 244, 244, 20)',     # 完全透明填充
                'outline_color': '#F4F4F4',      # 边框颜色为 #FF0033（RGB 255,0,51）
                'outline_width': '1'            # 边框宽度为2（单位：毫米）
            })
            # 应用符号到图层
            temp_layer.renderer().setSymbol(symbol)
            # 强制刷新显示
            temp_layer.triggerRepaint()
            iface.mapCanvas().refreshAllLayers()







            # 创建新要素并添加到临时图层  (源小区500米范围内所有的 源小区和目标小区 图形)
            new_distance_features = []
            region_eci_set = set()

            for matching_feature in source_distance_features:
                if matching_feature.attribute('sc_eci') not in region_eci_set:
                    region_eci_set.add(matching_feature.attribute('sc_eci'))
                    sc_new_feature = QgsFeature(temp_layer.fields())
                    sc_point = matching_feature.geometry()  # 源小区的图形
                    # 源小区
                    if matching_feature['sc_coverage_type'] == '室内':
                        sc_new_geom = sc_point.buffer(30 * 0.000009, 4)  # 室内站为 30米的近似圆,  15 segments 为圆弧精度
                    else:
                        if matching_feature['sc_azimuth'] >= 0:
                            radius=band_to_radius[matching_feature['sc_band']]
                            azimuth = matching_feature['sc_azimuth']
                            beamwidth = net_to_beamwidth[matching_feature['sc_net']]
                            sc_new_geom = create_sector(sc_point, azimuth, radius, beamwidth, 15)

                        else:
                            sc_new_geom = None
                            print(f"sc_azimuth异常值{matching_feature['sc_azimuth']}")
                    sc_new_feature.setGeometry(sc_new_geom)  # 设置要素的几何图形
                    sc_new_feature.setAttributes(matching_feature.attributes())  # 复制属性
                    sc_new_feature['same_or_opposite'] = 'region_sc'  # 设置 "same_or_opposite" 列的值为 "region"  标识为 500米范围内的 源小区
                    # layer.updateFeature(new_sc_feature)
                    new_distance_features.append(sc_new_feature)

                if matching_feature.attribute('sc_eci') not in region_eci_set:
                    region_eci_set.add(matching_feature.attribute('sc_eci'))

                    tc_new_feature = QgsFeature(temp_layer.fields())
                    tc_point = QgsGeometry.fromWkt(matching_feature['tc_cfg_point'])  # 从字段 tc_cfg_point 创建 目标小区扇区的原点

                    # 目标小区
                    if matching_feature['tc_coverage_type'] == '室内':
                        tc_new_geom = tc_point.buffer(30 * 0.000009, 4)  # 室内站为 30米的近似圆,  15 segments 为圆弧精度
                    else:
                        if matching_feature['tc_azimuth'] >= 0:
                            radius=band_to_radius[matching_feature['tc_band']]
                            azimuth = matching_feature['tc_azimuth']
                            beamwidth = net_to_beamwidth[matching_feature['tc_net']]
                            tc_new_geom = create_sector(tc_point, azimuth, radius, beamwidth, 15)
                        else:
                            tc_new_geom = None
                            print(f"tc_azimuth异常值{matching_feature['tc_azimuth']}")
                    tc_new_feature.setGeometry(tc_new_geom)  # 设置要素的几何图形
                    tc_new_feature.setAttributes(matching_feature.attributes())  # 复制属性
                    tc_new_feature['same_or_opposite'] = 'region_tc'  # 设置 "same_or_opposite" 列的值为 "tc"  标识为 500米范围内的 目标小区
                    new_distance_features.append(tc_new_feature)

            print('region_eci_set:', region_eci_set)

            # 提交修改
            provider.addFeatures(new_distance_features)








            # 创建新要素并添加到临时图层  (目标小区的图形)

            new_features=[]
            tc_ecis = []
            # 添加目标小区扇区到 临时图层
            for matching_feature in matching_features:
                new_feature = QgsFeature(temp_layer.fields())
                tc_point = QgsGeometry.fromWkt(matching_feature['tc_cfg_point'])   # 从字段 tc_cfg_point 创建 目标小区扇区的原点
                if matching_feature['tc_coverage_type']=='室内':
                    new_geom = tc_point.buffer(30*0.000009, 4)                 # 室内站为 30米的近似圆,  15 segments 为圆弧精度
                else:
                    if matching_feature['tc_azimuth']>=0:

                        radius = band_to_radius[matching_feature['tc_band']]
                        azimuth = matching_feature['tc_azimuth']
                        beamwidth = net_to_beamwidth[matching_feature['tc_net']]
                        new_geom = create_sector(tc_point, azimuth, radius, beamwidth, 15)

                    else:
                        new_geom = None
                        print(f"tc_azimuth异常值{matching_feature['tc_azimuth']}")
                # new_geom = QgsGeometry.fromWkt(matching_feature['tc_sector'])   # 从字段 tc_sector 创建 图形
                new_feature.setGeometry(new_geom)  # 复制几何
                new_feature.setAttributes(matching_feature.attributes())  # 复制属性
                new_features.append(new_feature)
                tc_ecis.append(matching_feature['tc_eci'])
            # 提交修改
            provider.addFeatures(new_features)





            # 创建新要素并添加到临时图层  (源小区的图形)
            new_sc_feature = QgsFeature(source_layer.fields())
            sc_point = source_feature.geometry()                   # 源小区扇区的原点
            if matching_feature['sc_coverage_type']=='室内':
                new_sc_geom = sc_point.buffer(30*0.000009, 4)                 # 室内站为 30米的近似圆,  15 segments 为圆弧精度
            else:
                if matching_feature['sc_azimuth']>=0:

                    radius = band_to_radius[matching_feature['sc_band']]
                    azimuth = matching_feature['sc_azimuth']
                    beamwidth = net_to_beamwidth[matching_feature['sc_net']]
                    new_sc_geom = create_sector(sc_point, azimuth, radius, beamwidth, 15)

                else:
                    new_sc_geom = None
                    print(f"sc_azimuth异常值{matching_feature['tc_azimuth']}")
            new_sc_feature.setGeometry(new_sc_geom)                 # 设置几何图形
            new_sc_feature.setAttributes([sc_eci])  # 设置属性 只设置 sc_eci 值 , 其他值均为 null
            
            print("tc_ecis: ",tc_ecis)
            provider.addFeatures([new_sc_feature])

            # 刷新图层
            temp_layer.updateExtents()

            # 将临时图层添加到项目
            QgsProject.instance().addMapLayer(temp_layer)
            print("#########################################")







            
            
            for new_feature in temp_layer.getFeatures():
                # print(new_feature['same_or_opposite'],type(new_feature['same_or_opposite']))
                h = QgsHighlight(iface.mapCanvas(), new_feature, temp_layer)
                # print(str(new_feature['same_or_opposite'])=='NULL')
                if new_feature['same_or_opposite']=='same':
                    h.setColor(QColor(0, 255, 0,50))          # 绿
                elif new_feature['same_or_opposite']=='opposite':
                    h.setColor(QColor(0, 0, 200,50))          # 蓝
                elif str(new_feature['same_or_opposite'])=='NULL':
                    h.setColor(QColor(255, 0, 0,80))          # 红
                

            # 强制刷新地图画布
            # iface.mapCanvas().refresh()

            # 激活图层
            if source_layer:
                iface.setActiveLayer(source_layer)

        except RuntimeError as e:
            print(e)















def destination_point(lon, lat, distance, azimuth_deg):
    """
    根据起点、距离和方位角计算目标点坐标（使用Haversine公式）
    :param lon: 起点经度
    :param lat: 起点纬度
    :param distance: 距离（米）
    :param azimuth_deg: 方位角（度）
    :return: QgsPointXY 目标点
    """
    azimuth_rad = math.radians(azimuth_deg)
    lat_rad = math.radians(lat)
    lon_rad = math.radians(lon)
    R = 6371000  # 地球平均半径（米）

    delta = distance / R  # 角距离（弧度）

    # 计算新纬度
    new_lat_rad = math.asin(
        math.sin(lat_rad) * math.cos(delta) + 
        math.cos(lat_rad) * math.sin(delta) * math.cos(azimuth_rad)
    )

    # 计算新经度
    new_lon_rad = lon_rad + math.atan2(
        math.sin(azimuth_rad) * math.sin(delta) * math.cos(lat_rad),
        math.cos(delta) - math.sin(lat_rad) * math.sin(new_lat_rad)
    )

    # 转换为度数并返回点
    return QgsPointXY(math.degrees(new_lon_rad), math.degrees(new_lat_rad))

def create_sector(location, azimuth, radius, beamwidth, step_angle=15):
    """
    创建扇形多边形几何体
    :param location: 中心点 (QgsPointXY 或 QgsGeometry点)
    :param azimuth: 主方向方位角（度）
    :param radius: 半径（米）
    :param beam_width: 波束宽度（度）
    :param step_angle: 生成精度（度，默认15）
    :return: QgsGeometry 多边形
    """
    # 处理输入点类型
    if isinstance(location, QgsGeometry):
        if location.wkbType() == QgsWkbTypes.Point and location.wkbType() != QgsWkbTypes.MultiPoint:
            location_point = location.asPoint()
        else:
            raise ValueError("Location must be a single point geometry")
    elif isinstance(location, QgsPointXY):
        location_point = location
    else:
        raise TypeError("Location must be QgsPointXY or QgsGeometry point")

    # 计算起止角度并归一化
    start_angle = (azimuth - beamwidth / 2) % 360
    end_angle = (azimuth + beamwidth / 2) % 360

    points = [location_point]  # 初始化点集

    # 生成圆弧点
    current_angle_deg = 0.0
    while current_angle_deg <= beamwidth:
        total_angle = (start_angle + current_angle_deg) % 360
        pt = destination_point(location_point.x(), location_point.y(), radius, total_angle)
        points.append(pt)
        current_angle_deg += step_angle

    points.append(location_point)  # 闭合多边形

    # 创建并验证几何
    polygon = QgsGeometry.fromPolygonXY([points])
    if not polygon.isGeosValid():
        polygon = polygon.makeValid()

    # 处理可能的多部分几何
    if polygon.isMultipart():
        parts = polygon.asMultiPolygon()
        if parts:
            polygon = QgsGeometry.fromPolygonXY(parts[0])

    return polygon



def select_distance_features(select_layer, select_feature, distance=500):
    """
    获取指定要素周围指定距离内的所有要素
    :param select_layer: 要查询的矢量图层（QgsVectorLayer）
    :param select_feature: 目标要素（QgsFeature）
    :param distance: 搜索距离（米）
    :return: 匹配要素列表（List[QgsFeature]）
    """

    from qgis.core import (
        QgsGeometry,
        QgsCoordinateTransform,
        QgsCoordinateReferenceSystem,
        QgsProject,
        QgsSpatialIndex,
        QgsWkbTypes,
        QgsPointXY
    )

    def get_utm_epsg(lon: float, lat: float) -> int:
        """根据经纬度计算UTM带EPSG代码"""
        utm_zone = int((lon + 180) // 6) + 1
        return 32600 + utm_zone if lat >= 0 else 32700 + utm_zone

    # 验证输入有效性
    if not select_layer.isValid():
        raise ValueError("无效的输入图层")
    if not select_feature.hasGeometry():
        return []

    # 获取目标几何体 v  source_feature.geometry()
    target_geom = QgsGeometry(select_feature.geometry())
    if target_geom.isEmpty():
        return []

    # 坐标系处理
    source_crs = select_layer.crs()
    is_geographic = source_crs.isGeographic()
    transform = None

    # 地理坐标系转换
    if is_geographic:
        # 计算目标点UTM带
        original_point = target_geom.asPoint()
        utm_epsg = get_utm_epsg(original_point.x(), original_point.y())
        dest_crs = QgsCoordinateReferenceSystem(utm_epsg)

        # 创建坐标系转换器
        transform = QgsCoordinateTransform(source_crs, dest_crs, QgsProject.instance())
        target_geom.transform(transform)
    else:
        dest_crs = source_crs

    # 生成缓冲区几何
    buffer_geom = target_geom.buffer(distance, 4)
    if buffer_geom.isEmpty():
        return []


    try:
        # 构建空间索引
        select_spatial_index = spatial_index[select_layer.id()]
    except KeyError:
        return []
    # 计算查询边界框
    if is_geographic:
        # 转换缓冲区范围回原坐标系
        reverse_transform = QgsCoordinateTransform(dest_crs, source_crs, QgsProject.instance())
        bbox = buffer_geom.boundingBox()
        corners = [
            QgsPointXY(bbox.xMinimum(), bbox.yMinimum()),
            QgsPointXY(bbox.xMaximum(), bbox.yMinimum()),
            QgsPointXY(bbox.xMaximum(), bbox.yMaximum()),
            QgsPointXY(bbox.xMinimum(), bbox.yMaximum())
        ]
        transformed_corners = [reverse_transform.transform(p) for p in corners]
        query_bbox = QgsRectangle(
            min(p.x() for p in transformed_corners),
            min(p.y() for p in transformed_corners),
            max(p.x() for p in transformed_corners),
            max(p.y() for p in transformed_corners)
        )
    else:
        query_bbox = buffer_geom.boundingBox()



    # from datetime import datetime
    # print(datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
    # 初步空间筛选
    candidate_ids = select_spatial_index.intersects(query_bbox)

    results = []
    request = QgsFeatureRequest().setFilterFids(candidate_ids)
    results = [f for f in select_layer.getFeatures(request)]



    return results


# select_layer = iface.activeLayer()
# select_feature = select_layer.getFeature(int(2654))
# select_distance_features(select_layer, select_feature, 500)






















# 激活工具
selectTool = MultiSelectMapTool(iface.mapCanvas())
iface.mapCanvas().setMapTool(selectTool)

# selectTool.create_temp_layer()



