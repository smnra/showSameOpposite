# -*- coding: utf-8 -*-
"""
/***************************************************************************
 showSameOpposite
                                 A QGIS plugin
 showSameOpposite
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-04-17
        git sha              : $Format:%H$
        copyright            : (C) 2025 by showSameOpposite
        email                : showSameOpposite
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .showSameOpposite_dialog import showSameOppositeDialog
import os.path,math






        
from qgis.PyQt.QtGui import QColor
from qgis.utils import iface

from qgis.gui import QgsMapTool, QgsMapMouseEvent, QgsHighlight
from qgis.core import QgsProject, QgsPointXY, QgsGeometry, QgsCoordinateTransform
from qgis.core import QgsRectangle, QgsFeatureRequest,QgsExpression, QgsWkbTypes,QgsVectorLayer,QgsFillSymbol,QgsFeature
from qgis.core import QgsDistanceArea,QgsUnitTypes
from PyQt5.QtWidgets import QListWidget, QDialog, QVBoxLayout, QListWidgetItem, QMessageBox
from PyQt5.QtCore import Qt,QVariant 

import sys






from qgis.core import  QgsCoordinateReferenceSystem










class showSameOpposite:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'showSameOpposite_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)



    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        
        self.action = QAction(QCoreApplication.translate('showSameOpposite', 'showSameOpposite'), self.iface.mainWindow())
        self.action_config = QAction(QCoreApplication.translate('showSameOpposite', 'Config'), self.iface.mainWindow())
        
        self.iface.registerMainWindowAction(self.action, 'Shift+S')
        self.iface.registerMainWindowAction(self.action_config, 'Shift+C')
        
        self.action.setIcon(QIcon(':/plugins/showSameOpposite/icon.png'))
        self.action_config.setIcon(QIcon(':/plugins/showSameOpposite/icon.png'))
        
        self.action.triggered.connect(self.run)
        self.action_config.triggered.connect(self.run_config)
        
        self.action.setEnabled(True)
        self.action_config.setEnabled(False)

        self.action.setWhatsThis("select a cell.")
        self.action_config.setWhatsThis("Config sector draw")

        self.iface.addToolBarIcon(self.action)
        self.iface.addToolBarIcon(self.action_config)

        self.iface.addPluginToMenu(QCoreApplication.translate('showSameOpposite', 'showSameOpposite'),self.action)
        self.iface.addPluginToMenu(QCoreApplication.translate('showSameOpposite', 'showSameOpposite'),self.action_config)

        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        self.iface.unregisterMainWindowAction(self.action)
        self.iface.unregisterMainWindowAction(self.action_config)
        
        self.iface.removeToolBarIcon(self.action)
        self.iface.removeToolBarIcon(self.action_config)
        
        self.iface.removePluginMenu(QCoreApplication.translate('showSameOpposite', 'showSameOpposite'), self.action)
        self.iface.removePluginMenu(QCoreApplication.translate('showSameOpposite', 'showSameOpposite'), self.action_config)




    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = showSameOppositeDialog()

        # show the dialog
        # self.dlg.show()
        # Run the dialog event loop
        # result = self.dlg.exec_()
        # See if OK was pressed
        # if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            # pass
        
        # 激活工具
        selectTool = MultiSelectMapTool(iface.mapCanvas())
        iface.mapCanvas().setMapTool(selectTool)
                
        
        
        
    def run_config(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = showSameOppositeDialog()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
        
        # 激活工具
        selectTool = MultiSelectMapTool(iface.mapCanvas())
        iface.mapCanvas().setMapTool(selectTool)  
        
        
        
        
        








class MultiSelectMapTool(QgsMapTool):
    def __init__(self, canvas):
        super().__init__(canvas)
        self.canvas = canvas
        self.source_fid = ''
        self.source_layer = ''

    def canvasReleaseEvent(self, event: QgsMapMouseEvent):
        # 获取点击点的坐标（地图坐标）
        point = self.toMapCoordinates(event.pos())
        # 获取所有可见的矢量图层
        layers = [iface.activeLayer()]
        found_features = []
        for layer in layers:
            if layer.type() == layer.VectorLayer:
                try:
                    # 将点坐标转换为图层坐标系
                    transform = QgsCoordinateTransform(self.canvas.mapSettings().destinationCrs(), layer.crs(), QgsProject.instance())
                    point_layer = transform.transform(point)
                except Exception as e:
                    continue
                # 创建请求，查找在该点处的要素
                tolerance = self.canvas.mapUnitsPerPixel() * 5  # 5像素的容差
                rect = QgsGeometry.fromRect(QgsRectangle(point_layer.x() - tolerance, point_layer.y() - tolerance,
                                                         point_layer.x() + tolerance, point_layer.y() + tolerance))
                request = QgsFeatureRequest().setFilterRect(rect.boundingBox())
                for feature in layer.getFeatures(request):
                    geom = feature.geometry()
                    if geom.intersects(rect):
                        found_features.append( (layer, feature) )
        # 显示选择对话框
        if len(found_features) > 0:
            dlg = QDialog()
            dlg.setWindowTitle("选择要素")
            layout = QVBoxLayout()
            list_widget = QListWidget()
            list_widget.setFixedSize(400, 300)  # 宽度 400px，高度 300px
            for layer, feature in found_features:
                # 显示图层名和属性，例如第一个字段的值
                display_value = f"{feature.attribute('sc_eci')},{feature.attribute('sc_net')},{feature.attribute('sc_cjf')},{feature.attribute('sc_ventor')}"
                print(display_value)
                item_text = f"{layer.name()}: {display_value}"
                item = QListWidgetItem(item_text)
                item.setData(1024, (layer, feature.id()))
                list_widget.addItem(item)
            list_widget.itemDoubleClicked.connect(dlg.accept)
            layout.addWidget(list_widget)
            dlg.setLayout(layout)
            if dlg.exec_():
                selected_item = list_widget.currentItem()
                if selected_item:
                    source_layer, source_fid = selected_item.data(1024)
                    # print('canvasReleaseEvent source_layer, source_fid',source_layer, source_fid)
                    self.create_temp_layer(source_layer, source_fid)
                    # self.canvas.refresh()
            else:
                print("提示", "未选择要素")
            
        else:
            print("提示", "未找到要素")









    def create_temp_layer(self,source_layer,source_fid):
        tmp_layer_parname = '临时草图_SC_eci_'
        
        # 移除选择的元素
        iface.activeLayer().removeSelection()


        # 获取项目中所有图层
        all_layers = QgsProject.instance().mapLayers().values()
        # 筛选符合条件的图层
        layers_to_remove = [layer for layer in all_layers if tmp_layer_parname in layer.name()]
        # 删除图层并输出结果
        if layers_to_remove:
            for layer in layers_to_remove:
                QgsProject.instance().removeMapLayer(layer.id())
            print(f"已删除 {len(layers_to_remove)} 个包含 '{tmp_layer_parname}' 的临时图层")
        else:
            print(f"未找到临时图层: 包含 '{tmp_layer_parname}' 的图层")








        # 获取激活图层
        # source_layer = self.source_layer
        # 获取 点击元素的 id 列
        # source_fid = self.source_fid
        # source_fid = "[% $id %]"








        # 从 id 获取元素
        try:
            print('source_layer: ',source_layer, type(source_layer))
            print('source_fid: ',source_fid, type(source_fid))
        
            source_feature = source_layer.getFeature(int(source_fid))
            sc_eci = source_feature["sc_eci"]
            print('sc_eci',sc_eci)





            # 构建查询条件
            expression = QgsExpression(f'"sc_eci"={sc_eci}')
            request = QgsFeatureRequest(expression)

            # 查询符合条件的要素
            matching_features = [f for f in source_layer.getFeatures(request)]






            # 创建临时内存图层
            # 从要素获取  几何图形类型 'Polygon'  和 坐标系 srid
            geometry_type = 'Polygon'
            srid = '4326'
            if source_feature:
                try:
                    srid = source_layer.crs().authid().split(':')[1]
                except Exception as e:
                    print(e)

            print(f"{geometry_type}?crs=EPSG:{srid}")
            
            
            temp_layer = QgsVectorLayer(f"{geometry_type}?crs=EPSG:{srid}", f"{tmp_layer_parname}{sc_eci}", "memory")
            provider = temp_layer.dataProvider()


            # 给图层添加字段（如果需要）
            source_fields = source_layer.fields()  # 获取源图层的字段结构
            provider.addAttributes(source_fields)
            temp_layer.updateFields()  # 刷新字段结构




            # 修改图层样式
            symbol = QgsFillSymbol.createSimple({
                'color': 'rgba(0, 0, 0, 0)',     # 完全透明填充
                'outline_color': '#FF0000',      # 边框颜色为 #FF0033（RGB 255,0,51）
                'outline_width': '1'            # 边框宽度为2（单位：毫米）
            })
            # 应用符号到图层
            temp_layer.renderer().setSymbol(symbol)
            # 强制刷新显示
            temp_layer.triggerRepaint()
            iface.mapCanvas().refreshAllLayers()








            # 创建新要素并添加到图层

            new_features=[]
            tc_ecis = []
            # 添加目标小区扇区到 临时图层
            for matching_feature in matching_features:
                new_feature = QgsFeature(temp_layer.fields())
                
                tc_point = source_feature.geometry()                   # 目标小区扇区的原点
                if matching_feature['tc_coverage_type']=='室内':
                    new_geom = tc_point.buffer(30*0.000009, 4)                 # 室内站为 30米的近似圆,  15 segments 为圆弧精度
                else:
                    if matching_feature['tc_azimuth']>=0:
                        new_geom = create_sector(tc_point, matching_feature['tc_azimuth'], matching_feature['tc_avg_site_distance'], 60, 15)
                    else:
                        new_geom = None
                        print(f'tc_azimuth异常值{tc_azimuth}')
                
                # new_geom = QgsGeometry.fromWkt(matching_feature['tc_sector'])   # 从字段 tc_sector 创建 图形
                new_feature.setGeometry(new_geom)  # 复制几何
                new_feature.setAttributes(matching_feature.attributes())  # 复制属性
                new_features.append(new_feature)
                tc_ecis.append(matching_feature['tc_eci'])

            # 提交修改
            provider.addFeatures(new_features)




            # 添加源小区扇区到 临时图层
            new_sc_feature = QgsFeature(source_layer.fields())
            new_sc_geom = source_feature.geometry()                 # 源小区的图形
            
                            
            sc_point = source_feature.geometry()                   # 源小区扇区的原点
            if matching_feature['sc_coverage_type']=='室内':
                new_sc_geom = sc_point.buffer(30*0.000009, 4)                 # 室内站为 30米的近似圆,  15 segments 为圆弧精度
            else:
                if matching_feature['sc_azimuth']>=0:
                    new_sc_geom = create_sector(sc_point, matching_feature['sc_azimuth'], matching_feature['sc_avg_site_distance'], 60, 15)
                else:
                    new_sc_geom = None
                    print(f'sc_azimuth异常值{sc_azimuth}')
            
            new_sc_feature.setGeometry(new_sc_geom)                 # 设置几何图形
            new_sc_feature.setAttributes([sc_eci])  # 设置属性 只设置 sc_eci 值 , 其他值均为 null
            
            print("tc_ecis: ",tc_ecis)
            provider.addFeatures([new_sc_feature])

            temp_layer.updateExtents()

            # 将临时图层添加到项目
            QgsProject.instance().addMapLayer(temp_layer)
            print("#########################################")











            # 定义要选中的要素ID列表（示例为ID 1,2,3）
            # neighbors_fid = [1]
            # 选中要素（替换原有选择）
            # temp_layer.selectByIds(neighbors_fid)

            # 设置全局选中颜色为蓝色（RGB: 0,0,255）
            # iface.mapCanvas().setSelectionColor(QColor(0, 0, 255,50))
            
            
            
            for new_feature in temp_layer.getFeatures():
                # print(new_feature['same_or_opposite'],type(new_feature['same_or_opposite']))
                h = QgsHighlight(iface.mapCanvas(), new_feature, temp_layer)
                # print(str(new_feature['same_or_opposite'])=='NULL')
                if new_feature['same_or_opposite']=='same':
                    h.setColor(QColor(0, 255, 0,50))          # 绿
                elif new_feature['same_or_opposite']=='opposite':
                    h.setColor(QColor(0, 0, 200,50))          # 蓝
                elif str(new_feature['same_or_opposite'])=='NULL':
                    h.setColor(QColor(255, 0, 0,80))          # 红
                

            # 强制刷新地图画布
            # iface.mapCanvas().refresh()





            # 激活图层
            if source_layer:
                iface.setActiveLayer(source_layer)



        except RuntimeError as e:
            print(e)















def destination_point(lon, lat, distance, azimuth_deg):
    """
    根据起点、距离和方位角计算目标点坐标（使用Haversine公式）
    :param lon: 起点经度
    :param lat: 起点纬度
    :param distance: 距离（米）
    :param azimuth_deg: 方位角（度）
    :return: QgsPointXY 目标点
    """
    azimuth_rad = math.radians(azimuth_deg)
    lat_rad = math.radians(lat)
    lon_rad = math.radians(lon)
    R = 6371000  # 地球平均半径（米）

    delta = distance / R  # 角距离（弧度）

    # 计算新纬度
    new_lat_rad = math.asin(
        math.sin(lat_rad) * math.cos(delta) + 
        math.cos(lat_rad) * math.sin(delta) * math.cos(azimuth_rad)
    )

    # 计算新经度
    new_lon_rad = lon_rad + math.atan2(
        math.sin(azimuth_rad) * math.sin(delta) * math.cos(lat_rad),
        math.cos(delta) - math.sin(lat_rad) * math.sin(new_lat_rad)
    )

    # 转换为度数并返回点
    return QgsPointXY(math.degrees(new_lon_rad), math.degrees(new_lat_rad))

def create_sector(location, azimuth, radius, beam_width, step_angle=15):
    """
    创建扇形多边形几何体
    :param location: 中心点 (QgsPointXY 或 QgsGeometry点)
    :param azimuth: 主方向方位角（度）
    :param radius: 半径（米）
    :param beam_width: 波束宽度（度）
    :param step_angle: 生成精度（度，默认15）
    :return: QgsGeometry 多边形
    """
    # 处理输入点类型
    if isinstance(location, QgsGeometry):
        if location.wkbType() == QgsWkbTypes.Point and location.wkbType() != QgsWkbTypes.MultiPoint:
            location_point = location.asPoint()
        else:
            raise ValueError("Location must be a single point geometry")
    elif isinstance(location, QgsPointXY):
        location_point = location
    else:
        raise TypeError("Location must be QgsPointXY or QgsGeometry point")

    # 计算起止角度并归一化
    start_angle = (azimuth - beam_width / 2) % 360
    end_angle = (azimuth + beam_width / 2) % 360

    points = [location_point]  # 初始化点集

    # 生成圆弧点
    current_angle_deg = 0.0
    while current_angle_deg <= beam_width:
        total_angle = (start_angle + current_angle_deg) % 360
        pt = destination_point(location_point.x(), location_point.y(), radius, total_angle)
        points.append(pt)
        current_angle_deg += step_angle

    points.append(location_point)  # 闭合多边形

    # 创建并验证几何
    polygon = QgsGeometry.fromPolygonXY([points])
    if not polygon.isGeosValid():
        polygon = polygon.makeValid()

    # 处理可能的多部分几何
    if polygon.isMultipart():
        parts = polygon.asMultiPolygon()
        if parts:
            polygon = QgsGeometry.fromPolygonXY(parts[0])

    return polygon












# 激活工具
selectTool = MultiSelectMapTool(iface.mapCanvas())
iface.mapCanvas().setMapTool(selectTool)

# selectTool.create_temp_layer()


