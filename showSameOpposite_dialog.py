# -*- coding: utf-8 -*-
"""
/***************************************************************************
 showSameOppositeDialog
                                 A QGIS plugin
 showSameOpposite
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-04-17
        git sha              : $Format:%H$
        copyright            : (C) 2025 by showSameOpposite
        email                : showSameOpposite
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from .config import select_distance_features,create_temp_layer,deduplicate_by_key

from .config import LayerMonitor,spatial_index


import os
import configparser
from qgis.PyQt import uic, QtWidgets
from qgis.core import QgsProject,QgsSpatialIndex,QgsFeatureRequest,QgsRectangle
from PyQt5.QtWidgets import  QListWidgetItem


CONFIG_FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'showSameOpposite_dialog_config.ui'))

SEARCH_FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'showSameOpposite_dialog_search.ui'))


class searchDialog(QtWidgets.QDialog, SEARCH_FORM_CLASS):
    def __init__(self, parent=None):
        super(searchDialog, self).__init__(parent)
        self.setupUi(self)
        self.update_layer_combobox()             # 更新图层 下拉框
        self.init_ui_connections()         # 初始化UI组件,连接信号与槽函数


    def init_ui_connections(self):
        self.pushButton.clicked.connect(self.search_cells)                      # 连接信号与槽函数
        self.comboBox_layer.currentIndexChanged.connect(self.update_field_comboBox)      # 连接信号与槽函数

    def search_cells(self):
        self.listWidget.clear()
        # 查找小区
        print(f'search {self.comboBox_search_type.currentText()}: {self.lineEdit.text()}.')
        layer = self.get_current_layer()     # 获取当前选中的图层对象
        if not layer:
            print(f'选择图层无效: {layer}.')
            return
        search_type = self.comboBox_search_type.currentText()
        search_text = self.lineEdit.text()

        # try:
        #     # 获取空间索引对象
        #     select_spatial_index = spatial_index.get(layer.id(), None)
        #     if select_spatial_index is None:
        #         spatial_index[layer.id()] = QgsSpatialIndex(layer.getFeatures())  # 添加索引对象
        #         select_spatial_index = spatial_index[layer.id()]
        # except KeyError:
        #     return []

        # 构建查询
        expression = f'"{search_type}" LIKE \'%{search_text}%\''
        request = QgsFeatureRequest().setFilterExpression(expression)

        # 执行查询
        matching_features = list(layer.getFeatures(request))
        # found_features 列表去重
        matching_features = deduplicate_by_key( matching_features, 'sc_eci')

        for feature_id in matching_features:
            feature = layer.getFeature(feature_id)
            sc_eci = feature.attribute('sc_eci')
            # sc_cellname = feature.get('sc_cellname','')  没有sc_cellname字段
            display_value = f"{feature.attribute('sc_eci')},{feature.attribute('sc_net')},{feature.attribute('sc_cjf')},{feature.attribute('sc_ventor')},{feature.attribute('sc_band')},{feature.attribute('sc_coverage_type')},{feature.attribute('sc_coverage_region')}"
            item = QListWidgetItem(display_value)
            item.setData(1024, (layer, feature.id()))
            self.listWidget.addItem(item)

        self.listWidget.itemDoubleClicked.connect(self.draw_cell)



    def draw_cell(self):
        selected_item = self.listWidget.currentItem()
        print(f'draw_cell,双击列表项: {selected_item.text()}')
        if selected_item:
            selected_layer, selected_fid = selected_item.data(1024)
            selected_feature = selected_layer.getFeature(int(selected_fid))

            # 选择要素500米范围内的所有要素
            source_region = selected_feature["sc_coverage_region"]
            distance_dict = {'市区': 500, '县城': 800, '乡镇': 1000, '农村': 1500}
            distance = distance_dict[source_region]
            source_distance_features = select_distance_features(selected_layer, selected_fid, distance=distance)
            create_temp_layer(selected_layer, source_distance_features, selected_fid)
            # self.canvas.refresh()

        else:
            # 信息提示弹窗
            # QMessageBox.information(iface.mainWindow(), "提示", "没有选中要素，请检查当前激活图层！")
            # 警告弹窗
            # QMessageBox.warning(None, "警告", "文件路径不存在")
            # 错误弹窗
            # QMessageBox.critical(iface.mainWindow(), "错误", "图层加载失败")
            print("提示", "已取消选择要素.")



    def get_current_layer(self,layerName = None):
        """从图层名称获取图层对象"""
        """获取当前选中的图层对象"""
        if not layerName:
            layer_name = self.comboBox_layer.currentText()
        else:
            layer_name = layerName

        if layer_name:
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]
            print('current_layer:', layer)
            return layer
        else:
            return None

    def update_layer_combobox(self):
        """填充图层到下拉框"""
        self.comboBox_layer.clear()
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.type() == layer.VectorLayer:
                # 填充图层到下拉框
                self.comboBox_layer.addItem(layer.name())
        # 图层下拉框默认选中最后一个图层
        self.comboBox_layer.setCurrentIndex(self.comboBox_layer.count()-1)
        # 填充字段下拉框
        self.update_field_comboBox(self.comboBox_layer.currentText())



    def update_field_comboBox(self, layer_name=None):
        self.comboBox_search_type.clear()
        """根据当前图层更新字段下拉框"""
        if not layer_name:
            layer = self.get_current_layer(layer_name)     # 获取当前选中的图层对象
        else:
            # 获取当前选择的图层名称
            currentLayerName = self.comboBox_layer.currentText()
            layer = self.get_current_layer(currentLayerName)

        if not layer:
            print(f'未找到图层: {layer_name}')
            return
        for field in layer.fields():
            if field.name() in ['sc_eci','sc_net','sc_cjf','sc_ventor','sc_band','sc_coverage_type','sc_coverage_region']:
                # 填充字段到下拉框
                self.comboBox_search_type.addItem(field.name())

        self.comboBox_search_type.setStyleSheet("background: #66F8DC")

        # 选中'sc_eci'字段
        self.comboBox_search_type.setCurrentIndex(self.getComboBoxItemIndex(self.comboBox_search_type,'sc_eci'))

    def  getComboBoxItemIndex(self, comboBox, itemText):
        # 获取下拉框指定文本的索引
        for i in range(comboBox.count()):
            if comboBox.itemText(i) == itemText:     # 找到指定文本
                return i
        return -1










class showSameOppositeDialog(QtWidgets.QDialog, CONFIG_FORM_CLASS):
    def __init__(self, parent=None):
        super(showSameOppositeDialog, self).__init__(parent)
        self.setupUi(self)

        # 初始化配置存储
        self.config = configparser.ConfigParser()
        self.init_ui_connections()         # 初始化UI组件,连接信号与槽函数

        self.setup_radio_buttons()         # 初始化单选按钮组

        self.populate_layers()             # 更新图层 下拉框


    def init_ui_connections(self):
        """连接信号与槽函数"""
        # 单选按钮切换时更新控件状态
        self.wktRadioButton.toggled.connect(self.update_wkt_controls_state)
        self.lonlatRadioButton.toggled.connect(self.update_lonlat_controls_state)
        # 按钮框信号连接
        self.button_box.accepted.connect(self.save_config)


    def  getComboBoxItemIndex(self, comboBox, itemText):
        """获取下拉框指定文本的索引"""
        for i in range(comboBox.count()):
            if comboBox.itemText(i) == itemText:     # 找到指定文本
                return i
        return -1


    def populate_layers(self):
        """填充图层到下拉框"""
        self.layerComboBox.clear()
        layers = QgsProject.instance().mapLayers().values()
        self.layerComboBox.addItems([layer.name() for layer in layers])
        self.layerComboBox.setCurrentIndex(self.layerComboBox.count()-1)   # 默认选中最后一个图层

    def setup_radio_buttons(self):
        """初始化单选按钮组"""
        self.radio_group = QtWidgets.QButtonGroup(self)
        self.radio_group.addButton(self.wktRadioButton)
        self.radio_group.addButton(self.lonlatRadioButton)
        # self.wktRadioButton.setChecked(True)
        # self.lonlatRadioButton.setChecked(False)

    def get_current_layer(self):
        """获取当前选中的图层对象"""
        layer_name = self.layerComboBox.currentText()
        if layer_name:
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]
            print('current_layer:', layer)
            return layer
        else:
            return None


    def update_wkt_controls_state(self):
        """更新控件可用状态"""
        """根据当前图层更新字段下拉框"""
        layer = self.get_current_layer()     # 获取当前选中的图层对象
        if not layer:
            print(layer)
            return
        fields = [field.name() for field in layer.fields()]         # 获取当前图层字段列表

        # 点击 单选按钮时，更新控件状态
        wkt_editable = True

        # wkt控件可用
        # self.wktRadioButton.setChecked(wkt_editable)                # 单选按钮置为选中状态
        for combo in [self.scWktComboBox,self.tcWktComboBox, self.scAzimuthComboBox, self.tcAzimuthComboBox, self.scRadiusComboBox, self.tcRadiusComboBox,self.coverageRegionComboBox]:
            combo.clear()
            combo.editable = wkt_editable
            combo.setStyleSheet("background: #66F8DC" if wkt_editable else "")
            combo.addItems(fields)  # wkt相关控件下拉框添加字段

        # 选中第一个字段
        self.scWktComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.scWktComboBox,'sc_eci'))
        self.tcWktComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.tcWktComboBox,'tc_cfg_point'))
        self.scAzimuthComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.scAzimuthComboBox,'sc_azimuth'))
        self.tcAzimuthComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.tcAzimuthComboBox,'tc_azimuth'))
        self.scRadiusComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.scRadiusComboBox,'sc_avg_site_distance'))
        self.tcRadiusComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.tcRadiusComboBox,'tc_avg_site_distance'))
        self.coverageRegionComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.coverageRegionComboBox,'sc_coverage_region'))
        # 设置经纬度相关字段不可用
        for combo in [self.scLonComboBox, self.scLatComboBox, self.tcLonComboBox, self.tcLatComboBox]:
            combo.clear()
            combo.editable=(not wkt_editable)
            combo.setStyleSheet("" if wkt_editable else "background: #F0F0F0")

    def update_lonlat_controls_state(self):
        """更新控件可用状态"""
        """根据当前图层更新字段下拉框"""
        layer = self.get_current_layer()     # 获取当前选中的图层对象
        if not layer:
            print(layer)
            return
        fields = [field.name() for field in layer.fields()]         # 获取当前图层字段列表

        # 点击 单选按钮时，更新控件状态
        lonlat_editable = True

        # 经纬度相关控件设置可用
        for combo in [self.scLonComboBox, self.scLatComboBox, self.tcLonComboBox, self.tcLatComboBox, self.scAzimuthComboBox, self.tcAzimuthComboBox, self.scRadiusComboBox, self.tcRadiusComboBox,self.coverageRegionComboBox]:
            combo.clear()
            combo.editable=(lonlat_editable)
            combo.setStyleSheet("background: #66F8DC" if lonlat_editable else "")
            combo.addItems(fields)  # wkt相关控件下拉框添加字段

        # 选中第一个字段
        self.scLonComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.scLonComboBox,'sc_eci'))
        self.scLatComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.scLatComboBox,'tc_eci'))
        self.tcLonComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.tcLonComboBox,'sc_eci'))
        self.tcLatComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.tcLatComboBox,'tc_eci'))
        self.scAzimuthComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.scAzimuthComboBox,'sc_azimuth'))
        self.tcAzimuthComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.tcAzimuthComboBox,'tc_azimuth'))
        self.scRadiusComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.scRadiusComboBox,'sc_avg_site_distance'))
        self.tcRadiusComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.tcRadiusComboBox,'tc_avg_site_distance'))
        self.coverageRegionComboBox.setCurrentIndex(self.getComboBoxItemIndex(self.coverageRegionComboBox,'sc_coverage_region'))

        # wkt控件设置不可用                            # 更新wkt控件字段下拉框
        for combo in [self.scWktComboBox, self.tcWktComboBox]:
            combo.clear()
            combo.editable = not lonlat_editable
            combo.setStyleSheet("" if lonlat_editable else "background: #F0F0F0")




    def save_config(self):
        """保存配置到文件"""
        layer = self.get_current_layer()
        print('layer,id:',layer,layer.id())
        if not layer:
            QtWidgets.QMessageBox.warning(self, "错误", "请先选择有效图层")
            return

        print(1)
        # 读取配置参数
        self.config['DEFAULT'] = {
            'layer_id': layer.id(),
            'mode': 'wkt' if self.wktRadioButton.isChecked() else 'lonlat',
            'sc_wkt_field': self.scWktComboBox.currentText(),
            'tc_wkt_field': self.tcWktComboBox.currentText(),
            'sc_azimuth': self.scAzimuthComboBox.currentText(),
            'tc_azimuth': self.tcAzimuthComboBox.currentText(),
            'sc_radius': self.scRadiusComboBox.currentText(),
            'tc_radius': self.tcRadiusComboBox.currentText(),
            'sc_coverage_region': self.coverageRegionComboBox.currentText(),

            'sc_lon_field': self.scLonComboBox.currentText(),
            'sc_lat_field': self.scLatComboBox.currentText(),

            'tc_lon_field': self.tcLonComboBox.currentText(),
            'tc_lat_field': self.tcLatComboBox.currentText(),
        }

        # 写入配置文件
        config_path = os.path.join(os.path.dirname(__file__), 'config.ini')
        with open(config_path, 'w') as configfile:
            self.config.write(configfile)

        self.accept()



